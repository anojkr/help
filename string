## Longest Common Subsequence
#Recursive Equation

	mat[i][j] = 0  								;	i = 0
	mat[i][j] = 0								;	j = 0

	mat[i][j] = mat[i-1][j-1] + 1				;	X[i-1] == Y[j-1]
	mat[i][j] = max(mat[i-1][j], mat[i][j-1]) 	; 	else X[i-1] != Y[j-1]

##Longest Common Substring
#Recursive Equation

	mat[i][j] = 0  							;	i = 0
	mat[i][j] = 0							;	j = 0

	mat[i][j] = mat[i-1][j-1] + 1			;	X[i-1] == Y[j-1]
	mat[i][j] = 0							; 	else X[i-1] != Y[j-1]


##Longest Palandromic Subsequence
#Recursive Equation
https://leetcode.com/problems/longest-palindromic-subsequence/
Bottom Up approch
Intiliaze mat with 0

	mat[i][j] = 1  								;	i == j
	mat[i][j] = mat[i-1][j-1] + 2				;	X[i-1] == Y[j-1]
	mat[i][j] = max(mat[i-1][j], mat[i][j-1]) 	; 	else X[i-1] != Y[j-1]1



##Longest Palandromic Substring
    def longestPalindrome(self, s)
        # Transform S into T.
        # For example, S = "abba", T = "^#a#b#b#a#$".
        # ^ and $ signs are sentinels appended to each end to avoid bounds checking
        T = '#'.join('^{}$'.format(s))
        n = len(T)
        P = [0] * n
        C = R = 0
        for i in range (1, n-1):
            P[i] = (R > i) and min(R - i, P[2*C - i]) # equals to i' = C - (i-C)
            # Attempt to expand palindrome centered at i
            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1
    
            # If palindrome centered at i expand past R,
            # adjust center based on expanded palindrome.
            if i + P[i] > R:
                C, R = i, i + P[i]
    
        # Find the maximum element in P.
        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))
        return s[(centerIndex  - maxLen)//2: (centerIndex  + maxLen)//2]
            


##Longest Increasing Subsequence
#Equation
https://leetcode.com/problems/longest-increasing-subsequence/

arr[N]
dp= [1]*N

for i in range(0, N):
	for j in range(0, i):
		if (arr[i] > arr[j] and dp[i] < dp[j]+1):
			dp[i] = dp[i] + 1

return max(dp)

##Anagram 
https://leetcode.com/problems/find-all-anagrams-in-a-string/
Solve using hash/dict



##Recursively remove all adjacent duplicates
using stack
1. Read the input 
2. if top of stack != arr[i]:
	add to stack
3. else: continue
